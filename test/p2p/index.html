
<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>P2P æª”æ¡ˆåˆ†äº« (WebRTC Demo)</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 100%; height: 100px; margin-top: 5px; }
    button { margin: 5px 0; }
    .section { border: 1px solid #ccc; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
    .copy-btn { margin-left: 5px; }

    /* å½ˆçª—é€²åº¦æ¢ï¼šé è¨­éš±è— (ä¸è¦åœ¨åŒä¸€ selector å†å¯« display:flex) */
    #progressModal {
      display: none; /* <-- é è¨­éš±è—ï¼ˆä¿®æ­£è™•ï¼‰ */
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.6);
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #progressBox {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      width: 300px;
    }
    #progressBar {
      width: 100%;
      height: 20px;
      background: #eee;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 10px;
    }
    #progressFill {
      width: 0;
      height: 100%;
      background: #4caf50;
    }
  </style>
</head>
<body>
  <h1>ğŸ”— P2P æª”æ¡ˆåˆ†äº« Demo</h1>

  <div class="section">
    <h2>ğŸ‘¤ Aï¼šç™¼é€è€…</h2>
    <h3>Step 1. å»ºç«‹ Offer</h3>
    <button id="createOffer">å»ºç«‹ Offer</button>
    <button class="copy-btn" onclick="copyText('offer')">è¤‡è£½ Offer</button>
    <textarea id="offer" placeholder="é€™è£¡æœƒç”Ÿæˆ Offerï¼Œè¤‡è£½çµ¦ B"></textarea>

    <h3>Step 3. è²¼ä¸Š B çš„ Answer</h3>
    <textarea id="answer" placeholder="æŠŠ B çµ¦çš„ Answer è²¼åœ¨é€™è£¡"></textarea>
    <button id="setAnswer">è¨­å®š Answer</button>

    <h3>ğŸ“‚ é¸æ“‡è¦å‚³é€çš„æª”æ¡ˆ</h3>
    <input type="file" id="fileInput">
  </div>

  <div class="section">
    <h2>ğŸ‘¤ Bï¼šæ¥æ”¶è€…</h2>
    <h3>Step 2. è²¼ä¸Š A çš„ Offer</h3>
    <textarea id="remoteOffer" placeholder="æŠŠ A çµ¦çš„ Offer è²¼åœ¨é€™è£¡"></textarea>
    <button id="createAnswer">ç”Ÿæˆ Answer</button>
    <button class="copy-btn" onclick="copyText('localAnswer')">è¤‡è£½ Answer</button>
    <textarea id="localAnswer" placeholder="ç”Ÿæˆçš„ Answerï¼Œè¤‡è£½çµ¦ A"></textarea>
  </div>

  <!-- å½ˆçª—é€²åº¦æ¢ -->
  <div id="progressModal" aria-hidden="true">
    <div id="progressBox">
      <h3>ğŸ“¥ æª”æ¡ˆæ¥æ”¶ä¸­...</h3>
      <div id="progressBar"><div id="progressFill"></div></div>
      <p id="progressText">0%</p>
    </div>
  </div>

  <script>
    let pc, channel, fileChunks = [], fileName = "download.bin", fileSize = 0, receivedSize = 0;

    function setupConnection() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      // å»ºç«‹ datachannelï¼ˆç™¼é€ç«¯æœƒç”¨åˆ°ï¼‰
      channel = pc.createDataChannel("file");
      channel.binaryType = "arraybuffer";

      // ç•¶é ç«¯ä¹Ÿå»ºç«‹ channel æ™‚ï¼ˆæ¥æ”¶ç«¯æœƒè§¸ç™¼ï¼‰
      pc.ondatachannel = e => {
        const recvChannel = e.channel;
        // æœ‰äº›å¯¦ä½œéœ€è¦æŒ‡å®š binaryType
        try { recvChannel.binaryType = "arraybuffer"; } catch (err) {}
        recvChannel.onmessage = ev => {
          // å˜—è©¦è§£ææª”æ¡ˆè³‡è¨Šï¼ˆJSONï¼‰
          if (typeof ev.data === "string") {
            try {
              const info = JSON.parse(ev.data);
              if (info.name) {
                fileName = info.name;
                fileSize = info.size || 0;
                receivedSize = 0;
                fileChunks = [];
                showProgress(0);
                return;
              }
            } catch (_) {
              // ä¸æ˜¯ JSONï¼Œå°±ç•¶æˆå­—ä¸²å…§å®¹ï¼ˆä¸è™•ç†ï¼‰
            }
            if (ev.data === "EOF") {
              const blob = new Blob(fileChunks);
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = fileName;
              a.click();
              fileChunks = [];
              hideProgress();
              alert(`ğŸ“¥ å·²æ¥æ”¶æª”æ¡ˆï¼š${fileName}`);
            }
            return;
          }

          // äºŒé€²ä½è³‡æ–™å¡Šï¼ˆArrayBuffer / Blobï¼‰
          const chunk = ev.data;
          // è‹¥æ˜¯ Blobï¼Œè½‰æˆ ArrayBuffer å† push
          if (chunk instanceof Blob) {
            const reader = new FileReader();
            reader.onload = () => {
              const ab = reader.result;
              fileChunks.push(new Uint8Array(ab));
              receivedSize += ab.byteLength;
              if (fileSize > 0) {
                const percent = Math.floor((receivedSize / fileSize) * 100);
                showProgress(percent);
              }
            };
            reader.readAsArrayBuffer(chunk);
          } else if (chunk instanceof ArrayBuffer) {
            fileChunks.push(new Uint8Array(chunk));
            receivedSize += chunk.byteLength;
            if (fileSize > 0) {
              const percent = Math.floor((receivedSize / fileSize) * 100);
              showProgress(percent);
            }
          } else {
            // å…¶ä»–æƒ…æ³ï¼ˆå­—ä¸²ç­‰ï¼‰
          }
        };
      };
    }
    setupConnection();

    // ä¸€éµè¤‡è£½ï¼ˆtextareaï¼‰
    function copyText(id) {
      const el = document.getElementById(id);
      el.select();
      document.execCommand("copy");
      // å–æ¶ˆé¸å–
      window.getSelection().removeAllRanges();
      alert("å·²è¤‡è£½ï¼");
    }

    // é¡¯ç¤ºé€²åº¦æ¢ï¼ˆä½¿ç”¨ inline style å°‡ display æ”¹ç‚º flexï¼‰
    function showProgress(percent) {
      const modal = document.getElementById("progressModal");
      modal.style.display = "flex";       // é¡¯ç¤ºç‚º flex ä»¥ä¾¿ç½®ä¸­
      modal.setAttribute("aria-hidden", "false");
      document.getElementById("progressFill").style.width = percent + "%";
      document.getElementById("progressText").innerText = percent + "%";
    }
    function hideProgress() {
      const modal = document.getElementById("progressModal");
      modal.style.display = "none";
      modal.setAttribute("aria-hidden", "true");
      document.getElementById("progressFill").style.width = "0%";
      document.getElementById("progressText").innerText = "0%";
    }

    // å»ºç«‹ Offer (A)
    document.getElementById("createOffer").onclick = async () => {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      pc.onicecandidate = e => {
        if (!e.candidate) {
          document.getElementById("offer").value = JSON.stringify(pc.localDescription);
        }
      };
    };

    // è¨­å®š Answer (A)
    document.getElementById("setAnswer").onclick = async () => {
      try {
        const answer = JSON.parse(document.getElementById("answer").value);
        await pc.setRemoteDescription(answer);
        alert("âœ… å·²é€£ç·šæˆåŠŸï¼Œå¯ä»¥é–‹å§‹å‚³æª”æ¡ˆï¼");
      } catch (err) {
        alert("Answer JSON è§£æéŒ¯èª¤æˆ–ç„¡æ•ˆï¼š " + err.message);
      }
    };

    // ç”Ÿæˆ Answer (B)
    document.getElementById("createAnswer").onclick = async () => {
      try {
        const offer = JSON.parse(document.getElementById("remoteOffer").value);
        await pc.setRemoteDescription(offer);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        pc.onicecandidate = e => {
          if (!e.candidate) {
            document.getElementById("localAnswer").value = JSON.stringify(pc.localDescription);
          }
        };
      } catch (err) {
        alert("Offer JSON è§£æéŒ¯èª¤æˆ–ç„¡æ•ˆï¼š " + err.message);
      }
    };

    // å‚³é€æª”æ¡ˆ (A) â€” åˆ†å¡Šå‚³é€ï¼Œå…ˆç™¼æª”æ¡ˆè³‡è¨Š (name/size)
    document.getElementById("fileInput").onchange = async e => {
      const file = e.target.files[0];
      if (!file) return;
      const chunkSize = 16 * 1024; // 16KB
      let offset = 0;

      // å‚³é€æª”æ¡ˆè³‡è¨Šï¼ˆå…ˆç™¼ metaï¼‰
      channel.send(JSON.stringify({ name: file.name, size: file.size }));

      while (offset < file.size) {
        const slice = file.slice(offset, offset + chunkSize);
        // ç›´æ¥ send Blobï¼ˆå¤§å¤šæ•¸ç€è¦½å™¨æ”¯æ´ï¼‰
        channel.send(slice);
        offset += chunkSize;
        // å°å»¶é²é¿å…å¡çˆ† channel
        await new Promise(r => setTimeout(r, 10));
      }
      channel.send("EOF");
      alert("ğŸ“¤ æª”æ¡ˆå‚³é€å®Œæˆï¼");
    };
  </script>
</body>
</html>
